{{ $baseUrl := .Site.BaseURL }}

<canvas style="display: block; width: 22%; height: 800px; position: fixed; top: 0; left: 0; z-index: -1;"></canvas>

<script type="text/javascript">
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var positionMap = ['x', 'y', 'z'];
/**
 * Class representing an instance.
 */

var Instance =
/*#__PURE__*/
function () {
  /**
   * Create an instance.
   * @param {object} settings
   */
  function Instance(settings) {
    _classCallCheck(this, Instance);

    // Assign default parameters
    Object.assign(this, {
      uniforms: {},
      geometry: {
        vertices: [{
          x: 0,
          y: 0,
          z: 0
        }]
      },
      mode: 0,
      modifiers: {},
      attributes: [],
      multiplier: 1,
      buffers: []
    }); // Assign optional parameters

    Object.assign(this, settings); // Prepare all required pieces

    this.prepareProgram();
    this.prepareUniforms();
    this.prepareAttributes();
  }
  /**
   * Compile a shader.
   * @param {number} type
   * @param {string} source
   */


  _createClass(Instance, [{
    key: "compileShader",
    value: function compileShader(type, source) {
      var shader = this.gl.createShader(type);
      this.gl.shaderSource(shader, source);
      this.gl.compileShader(shader);
      return shader;
    }
    /**
     * Create a program.
     */

  }, {
    key: "prepareProgram",
    value: function prepareProgram() {
      var gl = this.gl,
          vertex = this.vertex,
          fragment = this.fragment; // Create a new shader program

      var program = gl.createProgram(); // Attach the vertex shader

      gl.attachShader(program, this.compileShader(35633, vertex)); // Attach the fragment shader

      gl.attachShader(program, this.compileShader(35632, fragment)); // Link the program

      gl.linkProgram(program); // Use the program

      gl.useProgram(program); // Assign it to the instance

      this.program = program;
    }
    /**
     * Create uniforms.
     */

  }, {
    key: "prepareUniforms",
    value: function prepareUniforms() {
      var keys = Object.keys(this.uniforms);

      for (var i = 0; i < keys.length; i += 1) {
        var location = this.gl.getUniformLocation(this.program, keys[i]);
        this.uniforms[keys[i]].location = location;
      }
    }
    /**
     * Create buffer attributes.
     */

  }, {
    key: "prepareAttributes",
    value: function prepareAttributes() {
      if (typeof this.geometry.vertices !== 'undefined') {
        this.attributes.push({
          name: 'aPosition',
          size: 3
        });
      }

      if (typeof this.geometry.normal !== 'undefined') {
        this.attributes.push({
          name: 'aNormal',
          size: 3
        });
      }

      this.attributeKeys = []; // Convert all attributes to be useable in the shader

      for (var i = 0; i < this.attributes.length; i += 1) {
        this.attributeKeys.push(this.attributes[i].name);
        this.prepareAttribute(this.attributes[i]);
      }
    }
    /**
     * Prepare a single attribute.
     * @param {object} attribute
     */

  }, {
    key: "prepareAttribute",
    value: function prepareAttribute(attribute) {
      var geometry = this.geometry,
          multiplier = this.multiplier;
      var vertices = geometry.vertices,
          normal = geometry.normal; // Create an array for the attribute to store data

      var attributeBufferData = new Float32Array(multiplier * vertices.length * attribute.size); // Repeat the process for the provided multiplier

      for (var j = 0; j < multiplier; j += 1) {
        // Set data used as default or the attribute modifier
        var data = attribute.data && attribute.data(j, multiplier); // Calculate the offset for the right place in the array

        var offset = j * vertices.length * attribute.size; // Loop over vertices length

        for (var k = 0; k < vertices.length; k += 1) {
          // Loop over attribute size
          for (var l = 0; l < attribute.size; l += 1) {
            // Check if a modifier is provided
            var modifier = this.modifiers[attribute.name];

            if (typeof modifier !== 'undefined') {
              // Handle attribute modifier
              attributeBufferData[offset] = modifier(data, k, l, this);
            } else if (attribute.name === 'aPosition') {
              // Handle position values
              attributeBufferData[offset] = vertices[k][positionMap[l]];
            } else if (attribute.name === 'aNormal') {
              // Handle normal values
              attributeBufferData[offset] = normal[k][positionMap[l]];
            } else {
              // Handle other attributes
              attributeBufferData[offset] = data[l];
            }

            offset += 1;
          }
        }
      }

      this.attributes[this.attributeKeys.indexOf(attribute.name)].data = attributeBufferData;
      this.prepareBuffer(this.attributes[this.attributeKeys.indexOf(attribute.name)]);
    }
    /**
     * Create a buffer with an attribute.
     * @param {object} attribute
     */

  }, {
    key: "prepareBuffer",
    value: function prepareBuffer(attribute) {
      var data = attribute.data,
          name = attribute.name,
          size = attribute.size;
      var buffer = this.gl.createBuffer();
      this.gl.bindBuffer(34962, buffer);
      this.gl.bufferData(34962, data, 35044);
      var location = this.gl.getAttribLocation(this.program, name);
      this.gl.enableVertexAttribArray(location);
      this.gl.vertexAttribPointer(location, size, 5126, false, false, 0);
      this.buffers[this.attributeKeys.indexOf(attribute.name)] = {
        buffer: buffer,
        location: location,
        size: size
      };
    }
    /**
     * Render the instance.
     * @param {object} renderUniforms
     */

  }, {
    key: "render",
    value: function render(renderUniforms) {
      var _this = this;

      var uniforms = this.uniforms,
          multiplier = this.multiplier,
          gl = this.gl; // Use the program of the instance

      gl.useProgram(this.program); // Bind the buffers for the instance

      for (var i = 0; i < this.buffers.length; i += 1) {
        var _this$buffers$i = this.buffers[i],
            location = _this$buffers$i.location,
            buffer = _this$buffers$i.buffer,
            size = _this$buffers$i.size;
        gl.enableVertexAttribArray(location);
        gl.bindBuffer(34962, buffer);
        gl.vertexAttribPointer(location, size, 5126, false, false, 0);
      } // Update the shared uniforms from the renderer


      Object.keys(renderUniforms).forEach(function (key) {
        uniforms[key].value = renderUniforms[key].value;
      }); // Map the uniforms to the context

      Object.keys(uniforms).forEach(function (key) {
        var _uniforms$key = uniforms[key],
            type = _uniforms$key.type,
            location = _uniforms$key.location,
            value = _uniforms$key.value;

        _this.uniformMap[type](location, value);
      }); // Draw the magic to the screen

      gl.drawArrays(this.mode, 0, multiplier * this.geometry.vertices.length); // Hook for uniform updates

      if (this.onRender) this.onRender(this);
    }
    /**
     * Destroy the instance.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      for (var i = 0; i < this.buffers.length; i += 1) {
        this.gl.deleteBuffer(this.buffers.buffer);
      }

      this.gl.deleteProgram(this.program);
      this.gl = null;
    }
  }]);

  return Instance;
}();
/**
 * Class representing a Renderer.
 */


var Renderer =
/*#__PURE__*/
function () {
  /**
   * Create a renderer.
   * @param {HTMLElement} canvas - The element on which the scene will be rendered.
   * @param {object} context - Options used when getting the context.
   * @param {string} contextType - The context identifier defining the drawing context.
   * @param {object} settings - Options used when creating the renderer.
   */
  function Renderer() {
    var _this2 = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$canvas = _ref.canvas,
        canvas = _ref$canvas === void 0 ? document.querySelector('canvas') : _ref$canvas,
        _ref$context = _ref.context,
        context = _ref$context === void 0 ? {} : _ref$context,
        _ref$contextType = _ref.contextType,
        contextType = _ref$contextType === void 0 ? 'experimental-webgl' : _ref$contextType,
        _ref$settings = _ref.settings,
        settings = _ref$settings === void 0 ? {} : _ref$settings;

    _classCallCheck(this, Renderer);

    // Get context with optional parameters
    var gl = canvas.getContext(contextType, Object.assign({
      alpha: false,
      antialias: false
    }, context)); // Assign program parameters

    console.log(">> Phenomenon: gl object is: ", null);

    Object.assign(this, {
      gl: gl,
      canvas: canvas,
      uniforms: {},
      instances: new Map(),
      shouldRender: true
    }); // Assign default parameters

    Object.assign(this, {
      devicePixelRatio: 1,
      clearColor: [1.0, 1.0, 1.0, 1.0],
      position: {
        x: 0,
        y: 0,
        z: 2
      }
    }); // Assign optional parameters

    Object.assign(this, settings); // Create uniform mapping object

    this.uniformMap = {
      float: function float(loc, val) {
        return gl.uniform1f(loc, val);
      },
      vec2: function vec2(loc, val) {
        return gl.uniform2fv(loc, val);
      },
      vec3: function vec3(loc, val) {
        return gl.uniform3fv(loc, val);
      },
      vec4: function vec4(loc, val) {
        return gl.uniform4fv(loc, val);
      },
      mat2: function mat2(loc, val) {
        return gl.uniformMatrix2fv(loc, false, val);
      },
      mat3: function mat3(loc, val) {
        return gl.uniformMatrix3fv(loc, false, val);
      },
      mat4: function mat4(loc, val) {
        return gl.uniformMatrix4fv(loc, false, val);
      }
    }; // Enable depth

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL); // Set clear values

    debugger;

    if (gl.getContextAttributes().alpha === false) {
      gl.clearColor.apply(gl, _toConsumableArray(this.clearColor));
      gl.clearDepth(1.0);
    } // Hook for gl context changes before first render


    if (this.onSetup) this.onSetup(gl); // Handle resize events

    window.addEventListener('resize', function () {
      return _this2.resize();
    }); // Start the renderer

    this.resize();
    this.render();
  }
  /**
   * Handle resize events.
   */


  _createClass(Renderer, [{
    key: "resize",
    value: function resize() {
      var gl = this.gl,
          canvas = this.canvas,
          devicePixelRatio = this.devicePixelRatio,
          position = this.position;
      canvas.width = canvas.clientWidth * devicePixelRatio;
      canvas.height = canvas.clientHeight * devicePixelRatio;
      var bufferWidth = gl.drawingBufferWidth;
      var bufferHeight = gl.drawingBufferHeight;
      var ratio = bufferWidth / bufferHeight;
      gl.viewport(0, 0, bufferWidth, bufferHeight);
      var angle = Math.tan(45 * 0.5 * (Math.PI / 180)); // prettier-ignore

      var projectionMatrix = [0.5 / angle, 0, 0, 0, 0, 0.5 * (ratio / angle), 0, 0, 0, 0, -(100 + 0.001) / (100 - 0.001), -1, 0, 0, -2 * 100 * (0.001 / (100 - 0.001)), 0]; // prettier-ignore

      var viewMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; // prettier-ignore

      var modelMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, position.x, position.y, (ratio < 1 ? 1 : ratio) * -position.z, 1];
      this.uniforms.uProjectionMatrix = {
        type: 'mat4',
        value: projectionMatrix
      };
      this.uniforms.uViewMatrix = {
        type: 'mat4',
        value: viewMatrix
      };
      this.uniforms.uModelMatrix = {
        type: 'mat4',
        value: modelMatrix
      };
    }
    /**
     * Toggle the active state of the renderer.
     * @param {bool} shouldRender
     */

  }, {
    key: "toggle",
    value: function toggle(shouldRender) {
      if (shouldRender === this.shouldRender) return;
      this.shouldRender = typeof shouldRender !== 'undefined' ? shouldRender : !this.shouldRender;
      if (this.shouldRender) this.render();
    }
    /**
     * Render the total scene.
     */

  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      this.gl.clear(16640);
      this.instances.forEach(function (instance) {
        instance.render(_this3.uniforms);
      });
      if (this.onRender) this.onRender(this);
      if (this.shouldRender) requestAnimationFrame(function () {
        return _this3.render();
      });
    }
    /**
     * Add an instance to the renderer.
     * @param {string} key
     * @param {object} instanceParams
     */

  }, {
    key: "add",
    value: function add(key) {
      var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var instanceSettings = settings;
      instanceSettings.uniforms = Object.assign(settings.uniforms || {}, JSON.parse(JSON.stringify(this.uniforms)));
      Object.assign(settings, {
        gl: this.gl,
        uniformMap: this.uniformMap
      });
      var instance = new Instance(settings);
      this.instances.set(key, instance);
      return instance;
    }
    /**
     * Remove an instance from the renderer.
     * @param {string} key
     */

  }, {
    key: "remove",
    value: function remove(key) {
      var instance = this.instances.get(key);
      if (typeof instance === 'undefined') return;
      instance.destroy();
      this.instances.delete(key);
    }
    /**
     * Destroy the renderer and its instances.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _this4 = this;

      this.instances.forEach(function (instance, key) {
        instance.destroy();

        _this4.instances.delete(key);
      });
      this.toggle(false);
    }
  }]);

  return Renderer;
}();
</script>

<script type="text/javascript">
"use strict";

var multiplier = 400;
var begin = 0.0;
var duration = 0.6;

function h2r(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}

;

function getHSL(h, s, l) {
  h = (h % 1 + 1) % 1;
  s = Math.max(0, Math.min(1, s));
  l = Math.max(0, Math.min(1, l));
  if (s === 0) return [l, l, l];
  var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
  var q = 2 * l - p;
  return [h2r(q, p, h + 1 / 3), h2r(q, p, h), h2r(q, p, h - 1 / 3)];
}

;

function getRandom(value) {
  var floor = -value;
  return floor + Math.random() * value * 2;
}

var attributes = [{
  name: "aPositionStart",
  data: function data(index, total) {
    return [0, -1, 0];
  },
  size: 3
}, {
  name: "aControlPointOne",
  data: function data(index, total) {
    var angle = index * (2 * Math.PI / total);
    return [Math.cos(angle) * 1.5 + getRandom(0.5), 1.5 + getRandom(0.5), Math.sin(angle) * 1.5];
  },
  size: 3
}, {
  name: "aControlPointTwo",
  data: function data(index, total) {
    var angle = index * (2 * Math.PI / total);
    return [Math.cos(angle) + getRandom(1), 1 + getRandom(0.5), Math.sin(angle) + getRandom(1)];
  },
  size: 1
}, {
  name: "aPositionEnd",
  data: function data(index, total) {
    var angle = index * (2 * Math.PI / total);
    return [Math.cos(angle) + getRandom(2), -2, 0];
  },
  size: 3
}, {
  name: "aColor",
  data: function data(index, total) {
    return getHSL(begin + index / total * 0.2, 0.6 + getRandom(0.1), 0.6 + getRandom(0.1));
  },
  size: 3
}, {
  name: "aOffset",
  data: function data(i) {
    return [i * ((1 - duration) / (multiplier - 1))];
  },
  size: 1
}];
var uniforms = {
  uProgress: {
    type: "float",
    value: 0.0
  }
};
var vertex = "\n  attribute vec3 aPositionStart;\n  attribute vec3 aControlPointOne;  \n  attribute vec3 aControlPointTwo;  \n  attribute vec3 aPositionEnd;  \n  attribute vec3 aPosition;  \n  attribute vec3 aColor;  \n  attribute float aOffset;  \n\n  uniform float uProgress;\n  uniform mat4 uProjectionMatrix;\n  uniform mat4 uModelMatrix;\n  uniform mat4 uViewMatrix;\n\n  varying vec3 vColor;\n\n  vec3 bezier4(vec3 a, vec3 b, vec3 c, vec3 d, float t) {\n    return mix(mix(mix(a, b, t), mix(b, c, t), t), mix(mix(b, c, t), mix(c, d, t), t), t);\n  }\n\n  void main(){\n    float tProgress = min(1.0, max(0.0, (uProgress - aOffset)) / ".concat(duration, ");\n    vec3 newPosition = bezier4(aPositionStart, aControlPointOne, aControlPointTwo, aPositionEnd, tProgress);\n    gl_PointSize = 4.0;\n    gl_Position = uProjectionMatrix * uModelMatrix * uViewMatrix * vec4(newPosition + aPosition, 1.0);\n    vColor = aColor;\n  }\n");
var fragment = "\n  precision mediump float;\n\n  varying vec3 vColor;\n\n  void main(){\n    gl_FragColor = vec4(vColor, 1.0);\n  }\n";

var renderer = new Renderer({
  canvas: document.querySelector("canvas"),
  settings: {
    clearColor: [0.0, 0.0, 0.0, 0.0],
    position: {
      x: 0,
      y: 0,
      z: 1.2
    },
    shouldRender: true
  }
});
renderer.add("starling", {
  attributes: attributes,
  multiplier: multiplier,
  uniforms: uniforms,
  vertex: vertex,
  fragment: fragment,
  onRender: function onRender(instance) {
    instance.uniforms.uProgress.value += 0.004;

    if (instance.uniforms.uProgress.value >= 0.8) {
      instance.uniforms.uProgress.value = 0;
    }
  }
});
  
</script>